# AWS DVA-c02 ポケットスタディ

## SECTION 2 開発

- SDK や CLI がどの認証情報を使うかの優先順位:

  - 1. コードのオプションやパラメータで指定されたアクセスキー情報
  - 2. 環境変数
  - 3. aws/credentials
  - 4. ec2 の IAM Role

- EBS: OS やソフトフェアなどを起動するために使用
- EFS: 増減するデータの保存先
- こうすることで EC2 と EBS を使い捨てにでき設計にスケーラビリティを持たせることができる。

- AWS Storage Gateway:オンプレミスに仮想マシンをデプロイして保存したデータが自動的に S3 や EBS を使用するようにする。
  - ファイルゲートウェイ: NFS/SMB プロトコルで接続できる。
  - ボリュームゲートウェイ: iSCSI プロトコルで接続できる。
  - テープゲートウェイ: 仮想テープライブラリとして接続できる。
- <img width="836" alt="image" src="https://github.com/yoshikikasama/network-and-server/assets/61643054/dddcac6a-c639-4dd9-b403-33877eaec94f">

- CloudFront: エッジロケーションを使用してキャッシュコンテンツを配信。
- CloudFront Behavior: オリジンのファイルパスに応じてリダイレクト先を S3 Bucket または ALB にするかを設定できる。

- S3 の CORS(Cross Origin Resource Sharing):
  - Webfont Bucket にウェブフォントファイル
  - html-css-sample Bucket に CSS ファイル
  - CSS ファイルからウェブフォントファイルを参照:
  - CSS 例：@font-face{
    font-family: "samplefont";
    src:url("https//webfont.s3.amazonaws.com/sample.woff2")
    format("woff2");
    }
  - CORS により他の許可されたドメインからのリクエストを許可できるので、webfont Bucket で以下の設定を行う
  - bucket policy 例:
  - [
    {
    "AllowedHeaders":["*"],
    "AllowedMethods":["GET"],
    "AllowedOrigins":["https//html-css-sample.s3.amazonaws.com"]
    }
    ]
- ElastiCache:

  - メモリ内にデータを格納するインメモリデータストア
  - 複数ノードへのデータ分散によるスケーラビリティ: 複数 AZ に配置できる。
  - Memchached:
    - マルチスレッドをサポートしているので水平的なスケールアウトをしやすい。
    - 暗号化サポートなし
  - Redis:

    - AZ を跨いてリードレプリカを作成し、障害時にフェイルオーバーできる。永続的にデータ保存可能。
    - 静止時と転送時の暗号化をサポート
    - ソートセットなどのデータ構造を使用して頻繁にアクセスされるデータを保存、ソート、ランクづけできる。
    - シングルスレッド

  - ![image](https://github.com/yoshikikasama/network-and-server/assets/61643054/4bab373a-3e21-4c4c-9ae9-8658889d3027)

- Amazon DynamoDB:

  - パーティション(データの保存先)を分散させることで水平スケーリングを可能とするため、多くのリクエストが発生するアプリケーションに適している。
  - 例：game, mobile, EC site, ユーザー数の増減が発生するアプリケーションに向いている。
  - 実際に保存した容量のストレージ料金。
  - Read Capacity Unit(RCU):
    - 最大 4KB の項目を 1 秒間に 2 回の結果整合性で読み込み
    - 1 秒間に 1 回の強力な整合性で読み込み
      Write Capacity Unit (WCU):
      - 最大 1KB の項目を 1 秒間に 1 回書き込む。
  - primary key が一つ目のインデックス。
  - ローカルセカンダリインデックス: table 作成時に作成。partition key は既存と同じ。ソートキーを追加。強整合性の読み取りオプションを提供する。
  - グローバルセカンダリインデックス: primary key とは無関係な partition key でクエリ検索できる。あとから作成可能。強整合性の読み取りオプションを提供していない。
  - DynamoDB ストリーム: 項目の更新情報がストリームに格納される。更新情報を lambda に渡して後続処理可能。
  - DynamoDB Global table: 他の region に table レプリカを作成可能。
  - DynamoDB Accelerator(DAX): インメモリキャッシュを使って DynamoDB table への数ミリ秒のレイテンシーを数秒に短縮できる。

- 強整合性 の場合、データの更新の際にデータベースをロックすることによってデータの一貫性（Consistency）を担保するが、ロックされる期間が長いほどその間のデータベース・アクセスがブロックされ、可用性（Availability）を犠牲にすることになる。
- 結果整合性 はデータの更新でデータベースがロックされることはないため、可用性とスケーラビリティを維持することができる。その代わりノード間でのデータの一貫性はデータ複製にかかる時間に依存することになるため、必ずしも担保されない。

- Lambda:

  - CPU 性能とネットワーク帯域はメモリサイズに依存する。

- Amazon ECS:

  - ECS クラスター: コンテナの実行環境管理単位
  - タスク定義:
    - コンテナイメージ
    - タスクサイズ
    - 使用するポート
    - コンテナタスクが AWS サービスへのアクセスを許可するための IAM ロール
    - コンテナを実行するための IAM Role
    - 環境変数
    - ログ記録など
  - サービス:
    - 実行するタスク定義
    - コンテナを配置する VPC
    - サブネット
    - SG
    - スケーリングポリシー
    - インフラストラクチャなど
  - タスク: サービスによって起動したコンテナアプリケーションの実行単位

- API Gateway:

  - Lambda proxy 統合: API へのリクエストに含まれる情報をそのまま Lambda 関数に渡す。リクエストメッセージの変換なし。
  - Canary Deploy: 設定した割合で新にデプロイした API へリクエストを割り振る。問題なければ Canary の昇格から全ステージにデプロイする。

- WebSocket プロトコル:

  - サーバとクライアントが一度コネクションを確立すると、その後の通信を専用プロトコルで行う。
  - サーバプッシュ機能:一度コネクションを確立したあとは、サーバとクライアントのどちらからも通信を行うことが可能
  - 通信量削減: 一度コネクションを確立するとそのコネクション上で通信を行う(HTTP のように、通信のたびにコネクションを作らない)
  - ヘッダのサイズが最小 2byte、最大 14byte と小さい
  - WebSocket プロトコルではまずコネクションの確立(ハンドシェイク)を行うことで、双方向通信の実現がされる
    - 通信の仕組み ① 　-ハンドシェイク-
      - ハンドシェイクは HTTP 通信によって行われる。
      - リクエスト: HTTP の Upgrade ヘッダを使用し、プロトコルの変更を行う。
      - レスポンス: ステータスコード 101「Switching Protocols」が返る。
      - ハンドシェイクによってコネクションが確立し、これ以降は HTTP ではなく WebSocket のプロトコルで通信が行われることになる。
    - 通信の仕組み ② 　-双方向通信の実現-
      - ハンドシェイクによってコネクションが確立すると、双方向通信を WebSocket プロトコルで行うことができるようになる。
      - 送信データはフレームという単位で扱われる。

- AWS AppSync: GraphQL API と Pub/Sub API を高速に開発できるサービス。

- Amazon SQS:
  - Queue のないシステム: Insert 処理時に RDS インスタンスにフェイルオーバーが発生していたら DB はリクエストを受け付けることができず Insert 処理はエラーとなる。
  - Queue があるシステム: DB が応答しない場合は、Queue に message を残して処理を続けられる。
  - 可視性タイムアウト: consumer が message を受信し たタイミングでメッセージは他の consumer から見えなくする。そして処理が正常完了して message を削除することで他の consumer が重複処理することはない。
  - デッドレターキュー: 可視性タイムアウトのリトライ回数を決めておき、制限に達した message を移動する場所。
  - 標準キュー:
    - 無制限のパフォーマンス
    - 少なくとも 1 回以上の配信: consumer が受信して処理して削除するまでを 1 回の配信とした時に削除した message や可視性タイムアウトに入った message を他の consumer が受信してしまうことがある。
    - 先入先出はベストエフォート
  - FIFO キュー:
    - 1 秒間 300 回の API リクエスト
    - 1 回のみの配信サポート
    - FIFO

## SECTION 3 セキュリティ

- Amazon Cognito:

  - ユーザープール: ユーザープロファイルの管理ができる。MFA、本人認証などユーザー認証の一般的な機能の設定ができる。Web ID フェデレーション(Facebook, Google, Apple, Amazon)設定ができる。
  - ID プール:IAM Role と認証プロバイダーを設定できる。認証されてないゲストロールから AWS サービスにリクエストする設定もできる。

- AWS CloudHSM: 暗号化に使用するキー管理に専用ハードウェアが必要となる要件で使用。

- S3 の暗号化:
  - クライアントサイド暗号化: 暗号化してから upload
    - CSE-KMS, CSE-C
  - サーバーサイド暗号化: S3 に保管される際にデータの暗号化
    - SSE-S3: S3 が管理するキーによるサーバー側暗号化
    - SSE-KMS: KMS で管理しているキーを使ったサーバー側暗号化。
    - SSE-C: ユーザー指定キーによるサーバー側暗号化。

## SECTION 4 デプロイ

- ビルド: コードのコンパイルやユニットテスト。コンテナ環境の場合は、コンテナイメージを作成し、レジストリに push する。
- テスト: ビルドフェーズではできなかったテストを本番に近い環境で行う。

- CI/CD Pipeline:

  - CI(Continuous Integration): ソースコードを開発しリポジトリへ新規に登録すること、変更して更新することなどを一般的にチェックインするという。ソースコードを毛一足的にチェックインし、ビルドとテストを自動化し、コードを検証する手法を継続的 Integration という。
  - CD(Continuous Deployment): テスト環境、本番環境へのデプロイ、リリースまでを自動化する。自動化することにより、デプロイが頻繁に繰り返し発生したとしてもボトルネックや遅延、リスクの原因にならないようできる。

| デプロイパターン | 特徴                                                                             |
| ---------------- | -------------------------------------------------------------------------------- |
| In-Place         | 稼働中の環境を新しいアプリケーションで更新する。                                 |
| Linear (線形)    | 毎分 10%ずつ新環境の割合を増やすなど、時系列グラフとした場合、直線的に推移する。 |
| Canary           | 最初は 10%のみで、数分後に全てなど、割合によって段階的にリリースする。           |
| Blue/Green       | 現バージョン環境とは別に新バージョン環境を構築し、リクエスト送信先を切り替える。 |
| Rolling          | サーバーをいくつかのグループに分けて、グループごとに In-Place 更新を行う。       |
| Immutable        | 現バージョンサーバーとは別に新バージョンサーバーにを構築する。                   |
| All at once      | すべてのサーバーで同時に In-Place 更新を行う。                                   |

- AWS CodeCommit:

  - SSH または HTTPS での接続:
    - 認証情報を IAM ユーザーごとに作成
    - SSH: local でキーペアを作成し公開鍵を upload する。
    - HTTPS: IAM ユーザーに Git 認証情報を作成して端末に git-remote-codecommit をインストールして使用する。

- AWS CodeDeploy: S3 や Github からリビジョンを EC2 インスタンス、Auto Scaling, オンプレミスサーバー、ECS, Lambda などへデプロイする。
- AWS CodePipeline: コードが変更されるたびにコードをビルド、テスト、デプロイする。

- CloudFormation:
  - Mappings: Mappings で region ごとの AIM を定義して FindMap 関数で AWS:Region を key として値を参照する。
- Conditions: dev と prod での条件によってリソース有無を管理したりする。

- サーバーレスアーキテクチャ: ユーザーアクセスを可能とする web システム:
  - HTML, CSS, JavaScript, 画像でできた静的な web サイトを S3 と CloudFront を使ってユーザーに配信する。ユーザーのサイナップ、サインインは Cognito によって認証できる。サインインイベントによって Lambda 関数が実行されて、DynamoDB table にログを記録する。
  - ユーザーがフォームに入力した情報を送信ボタンから送信する。API Gateway 経由で Lambda 関数が実行されて送信内容の正当性を判定し、SNS TOPIC へ通知する。
  - SNS TOPIC の Subscriber として設定されている SQS Queue に送信メッセージが格納される。
  - message が格納されたことを trigger にして次の Lambda 関数が実行され、その message を parameter として Step Funcstion statemachine が実行される。
  - Step Functions state machine では並列や分岐などのワークフロー制御をしながら、さらに様々な AWS サービスと連携し、データのバックエンド処理を管理する。
  - 最終的にはユーザーの送信内容が DynamoDB table に格納される。

## SECTION 5 トラブルシューティングと最適化

- 5xx: サーバー側エラー。再試行。
- 4xx: クライアント側エラー。ソースコードの修正。
- スロットリングエラー: サービス API の制限リクエストに達した。
- エクスポネンシャルバックオフ:指数バックオフ、指数関数的再試行とも呼ばれ、再試行前の待機時間を徐々に長くしたり random な遅延時間を使用したりする。

## 特に理解が追いついていない点まとめ

- DynamoDB:

  - グローバルセカンダリーインデックス:
    - 新たにパーティションキー、ソートキーを設定したいとき
    - 強整合性の読み取りオプションをサポートしていない
  - ローカルセカンダリーインデックス:
    - 既存のパーティションキーに新たにソートキーを設定したいとき
    - 強整合性の読み取りオプションをサポートしている
  - RCU:
    - 結果整合性:
    - 強い整合性:
  - WCU:

- AWS X-ray: サンプリング Request=リザーバサイズ＋（1 秒あたりの着信 Request-リザーバサイズ） \* 固定レート

- deploy 種類:

- API Gateway:

  - HTTP_PROXY 統合: API Gateway からの介入なしでクライアントとバックエンドが直接対話できる。クライアントが送信したメソッドリクエストをバックエンドに渡し、バックエンドの HTTP エンドポイントまたは web server で受信リクエストデータを解析して返すレスポンスを決定する。
  - HTTP 統合: HTTP エンドポイントを経由して API にアクセスすることを可能にし、メソッドリクエストから統合リクエストとと統合レスポンスからメソッドレスポンスへのデータマッピングを設定する必要がある。
  - AWS_PROXY 統合: Lambda 関数呼び出しアクションと統合できるタイプ。
  - AWS 統合: AWS サービスアクションを統合する場合に使用される。メソッドリクエストから統合リクエストとと統合レスポンスからメソッドレスポンスへのデータマッピングを設定する必要がある。
  - ![image](https://github.com/yoshikikasama/network-and-server/assets/61643054/360d3c82-6f49-481c-b7d4-35656d2cbec1)

- カナリア デプロイ: すでにデプロイされているバージョンと新しいバージョンの間でトラフィックを分割し、ユーザーのサブセットに展開して完全にロールアウトするアプリケーションの段階的なロールアウトです。
- ![image](https://github.com/yoshikikasama/network-and-server/assets/61643054/33ffd56d-549f-4119-95b6-bef1f36d6dc2)

1. **リソースベースのポリシー(許可ポリシー)**:

   - これらのポリシーは、AWS リソースに直接アタッチされます。例えば、S3 バケットポリシー、IAM ロールの信頼ポリシーなどがあります。
   - リソースベースのポリシーでは、そのポリシーがアタッチされたリソースにアクセスすることが許可されるユーザーやロールを指定します。
   - このタイプのポリシーには、アクセス許可とともに、誰が（またはどのアカウントが）そのリソースにアクセスできるかを定義するプリンシパル要素が含まれます。

2. **ID ベースのポリシー(信頼ポリシー)**:
   - これらのポリシーは、IAM ユーザー、グループ、またはロールに直接アタッチされます。
   - ID ベースのポリシーは、そのポリシーがアタッチされた IAM エンティティ（ユーザー、グループ、ロール）が実行できるアクションと、それらのアクションが許可されるリソースを指定します。
   - これらのポリシーには、プリンシパル要素は含まれません。なぜなら、ポリシーは特定のユーザー、グループ、またはロールに関連付けられているため、プリンシパルは暗黙のうちに決定されます。

簡単に言うと、リソースベースのポリシーは「このリソースには誰がアクセスできるか」と定義し、ID ベースのポリシーは「このユーザー/グループ/ロールは何ができるか」と定義します。

- AWS Elastic Beanstalk:
- 構成要素:
- ![image](https://github.com/yoshikikasama/network-and-server/assets/61643054/83ca91bd-2654-4f48-a9f3-2f36c536f1ae)
- アプリケーション: トップレベルの論理単位。version, 環境, 環境設定が含まれている
- version: デプロイ可能なコード, version 管理
- 環境: 環境に応じて構築されるインフラ環境
- web server 環境： ウェブサイト、ウェブアプリケーション、または HTTP リクエストを処理するウェブ API を実行する環境
  - ![image](https://github.com/yoshikikasama/network-and-server/assets/61643054/9d35538c-1c71-4f02-8685-577782baac2e)
- worker 環境: 長時間実行するワークロードを処理するワーカーアプリケーションをオンデマンドで実行するか、スケジュールに従ってタスクを実行する環境
  - ![image](https://github.com/yoshikikasama/network-and-server/assets/61643054/c6a6b30d-dc83-41ad-abff-d0b46fdbc58b)
- deployment:
- in Place Deployment(Rolling Deploy): インスタンスは現行環境のものをそのまま利用し、新しいリビジョンのコードをその場で反映させる。
- Blue Green Deployment: 新しいリビジョンのコードを新しいインスタンスに反映させ、インスタンスごと入れ替える。
- デプロイポリシー： アプリケーションの新しい version をデプロイする時にどのようにデプロイするかを決めるポリシー。

  - All at once (一度にすべて): 既存インスタンスをに同時にデプロイするポリシー。
    - 一度に全てデプロイするのでダウンタイムが発生する。
    - 最も迅速にデプロイできる。
  - Rolling (ローリング): 既存インスタンスを利用してデプロイするポリシー。バッチサイズというデプロイを進める割合、もしくはインスタンスの個数を決定してデプロイを進める。
    - ダウンタイム発生しない
    - キャパシティが一時的に減る
    - 新旧アプリケーションが混在する時間がある
  - Rolling with additional batch (追加バッチによるローリング): インスタンス数を維持したまま新規と既存インスタンスを利用してデプロイするポリシー。バッチサイズに沿ったインスタンスを追加し、キャパシティを維持しながらインスタンスをデプロイする。
    - ダウンタイム発生しない
    - 新旧アプリケーションが混在する時間がある
    - 既存と新規インスタンスへのデプロイ
    - キャパシティを維持したままデプロイする
    - Rolling よりもデプロイ所要時間がかかる
    - 追加バッチは最後に削除する。
  - Immutable (イミュータブル): 既存インスタンスを更新せず、新規インスタンスを利用してデプロイするポリシー。グループを作成し、キャパシティを一時的に増やしてデプロイする。
    - 新規インスタンスへのデプロイ、ダウンタイム発生しない
    - デプロイに時間がかかる
    - キャパシティが一時的に増える
    - 新旧アプリケーションが混在する時間がある
  - Traffic splitting (トラフィック分割): 新規インスタンスで処理するが、さらにトラフィック制御し、振り分け先を変更してデプロイするポリシー。割合を設定して新 version を試し、問題なければ旧 version を終了させる。
    - 新規インスタンスへのデプロイ
    - 新バージョンで不具合があった時、一部ユーザーには影響が出る
    - デプロイに時間がかかる
    - 新旧アプリケーションが混在する時間がある

- SQS キューによるポーリング処理に EC2 が負荷がかかり、同じ EC2 内のソフトウェアアプリケーションの応答も悪くなる。
- ![image](https://github.com/yoshikikasama/network-and-server/assets/61643054/21a9820a-09f9-425e-92d8-4102a0b2fcd4)

- Amazon Cognito ID pool: 認証されて良いない ID へのアクセスを有効にすることがゲストユーザーに一時認証情報を提供するための最適なソリューション。ID プールは認可を扱い、他の ID Providor や未認証ユーザーに対しても一時的な認証情報を発行できる。
- Amazon Cognito User pool: 通常のユーザー認証に利用されるサービス、ゲストユーザーに対して一時認証を提供する目的には適していない。
